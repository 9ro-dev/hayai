pub mod openapi;

use axum::Router;
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use serde::Serialize;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::Arc;

// Re-exports
pub use hayai_macros::{get, post, put, delete, api_model};
pub use serde;
pub use serde_json;
pub use schemars;
pub use inventory;
pub use axum;

pub mod prelude {
    pub use crate::{get, post, put, delete, api_model};
    pub use crate::{HayaiApp, Dep, ApiError, Validate};
    pub use crate::axum::extract::Query;
}

/// Validation trait generated by api_model attribute
pub trait Validate {
    fn validate(&self) -> Result<(), Vec<String>>;
}

impl Validate for () {
    fn validate(&self) -> Result<(), Vec<String>> {
        Ok(())
    }
}

/// Trait for schema patches from validation attributes
pub trait HasSchemaPatches {
    fn patch_schema(props: &mut HashMap<String, openapi::PropertyPatch>);
}

/// Application state holding dependency injection container
#[derive(Clone)]
pub struct AppState {
    deps: Arc<HashMap<TypeId, Arc<dyn Any + Send + Sync>>>,
}

impl AppState {
    pub fn new() -> Self {
        Self { deps: Arc::new(HashMap::new()) }
    }

    pub fn get<T: 'static + Send + Sync>(&self) -> Option<Arc<T>> {
        self.deps
            .get(&TypeId::of::<T>())
            .and_then(|v| v.clone().downcast::<T>().ok())
    }
}

/// Dependency injection extractor
pub struct Dep<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> Dep<T> {
    pub fn from_app_state(state: &AppState) -> Self {
        let arc = state.get::<T>().expect("Dependency not registered");
        Dep(arc)
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Dep<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// API Error type
#[derive(Debug, Serialize)]
pub struct ApiError {
    #[serde(skip)]
    pub status: StatusCode,
    pub error: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<String>,
}

impl ApiError {
    pub fn bad_request(msg: String) -> Self {
        Self { status: StatusCode::BAD_REQUEST, error: msg, details: vec![] }
    }

    pub fn not_found(msg: String) -> Self {
        Self { status: StatusCode::NOT_FOUND, error: msg, details: vec![] }
    }

    pub fn internal(msg: String) -> Self {
        Self { status: StatusCode::INTERNAL_SERVER_ERROR, error: msg, details: vec![] }
    }

    pub fn validation_error(errors: Vec<String>) -> Self {
        Self {
            status: StatusCode::UNPROCESSABLE_ENTITY,
            error: "Validation failed".into(),
            details: errors,
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self)
            .unwrap_or_else(|_| r#"{"error":"Internal server error"}"#.to_string());
        (self.status, [("content-type", "application/json")], body).into_response()
    }
}

/// Route information collected by proc macros
pub struct RouteInfo {
    pub path: &'static str,
    pub axum_path: &'static str,
    pub method: &'static str,
    pub handler_name: &'static str,
    pub response_type_name: &'static str,
    pub is_vec_response: bool,
    pub vec_inner_type_name: &'static str,
    pub parameters: &'static [openapi::Parameter],
    pub has_body: bool,
    pub body_type_name: &'static str,
    pub success_status: u16,
    pub description: &'static str,
    pub tags: &'static [&'static str],
    pub security: &'static [&'static str],
    pub query_params_fn: Option<fn() -> Vec<openapi::DynParameter>>,
    pub register_fn: fn(Router<AppState>) -> Router<AppState>,
}

inventory::collect!(RouteInfo);

/// Schema information collected by api_model attribute
pub struct SchemaInfo {
    pub name: &'static str,
    pub schema_fn: fn() -> openapi::Schema,
    pub nested_fn: fn() -> std::collections::HashMap<String, openapi::Schema>,
}

inventory::collect!(SchemaInfo);

/// The main application struct
pub struct HayaiApp {
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    title: String,
    version: String,
    swagger_cdn_url: Option<String>,
    servers: Vec<openapi::Server>,
    security_schemes: HashMap<String, openapi::SecurityScheme>,
}

impl HayaiApp {
    pub fn new() -> Self {
        Self {
            deps: HashMap::new(),
            title: env!("CARGO_PKG_NAME").to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            swagger_cdn_url: None,
            servers: Vec::new(),
            security_schemes: HashMap::new(),
        }
    }

    pub fn title(mut self, title: &str) -> Self {
        self.title = title.to_string();
        self
    }

    pub fn version(mut self, version: &str) -> Self {
        self.version = version.to_string();
        self
    }

    pub fn swagger_cdn(mut self, url: &str) -> Self {
        self.swagger_cdn_url = Some(url.to_string());
        self
    }

    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }

    pub fn server(mut self, url: &str) -> Self {
        self.servers.push(openapi::Server { url: url.to_string() });
        self
    }

    pub fn security_scheme(mut self, name: &str, scheme: openapi::SecurityScheme) -> Self {
        self.security_schemes.insert(name.to_string(), scheme);
        self
    }

    pub fn bearer_auth(self) -> Self {
        self.security_scheme("bearerAuth", openapi::SecurityScheme {
            scheme_type: "http".to_string(),
            scheme: Some("bearer".to_string()),
            bearer_format: None,
            name: None,
            location: None,
        })
    }

    pub fn into_router(self) -> Router {
        let spec = self.generate_openapi_spec();
        let swagger_html = self.generate_swagger_html();

        let state = AppState {
            deps: Arc::new(self.deps),
        };
        let spec_json = serde_json::to_string_pretty(&spec.to_json_with_query_params())
            .expect("Failed to serialize OpenAPI spec");

        let mut app = Router::new();

        for route in inventory::iter::<RouteInfo> {
            app = (route.register_fn)(app);
        }

        let spec_json_clone = spec_json.clone();
        app = app.route("/openapi.json", axum::routing::get(move || {
            let spec = spec_json_clone.clone();
            async move {
                (StatusCode::OK, [("content-type", "application/json")], spec)
            }
        }));

        app = app.route("/docs", axum::routing::get(move || {
            let html = swagger_html.clone();
            async move {
                (StatusCode::OK, [("content-type", "text/html")], html)
            }
        }));

        app.with_state(state)
    }

    pub async fn serve(self, addr: &str) {
        let app = self.into_router();

        let listener = tokio::net::TcpListener::bind(addr).await
            .expect("Failed to bind to address");
        println!("ðŸš€ Hayai server running at http://{}", addr);
        println!("ðŸ“– Swagger UI available at http://{}/docs", addr);
        axum::serve(listener, app).await
            .expect("Server error");
    }

    fn generate_swagger_html(&self) -> String {
        let cdn_base = self.swagger_cdn_url.as_deref()
            .unwrap_or("https://unpkg.com/swagger-ui-dist@5");
        format!(
            r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="{cdn}/swagger-ui.css" >
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="{cdn}/swagger-ui-bundle.js"> </script>
    <script>
    SwaggerUIBundle({{
        url: "/openapi.json",
        dom_id: '#swagger-ui',
        presets: [SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset],
        layout: "BaseLayout"
    }})
    </script>
</body>
</html>"#,
            title = self.title,
            cdn = cdn_base,
        )
    }

    fn generate_openapi_spec(&self) -> openapi::OpenApiSpec {
        let mut schemas = HashMap::new();

        // Add ApiError schema
        schemas.insert("ApiError".to_string(), openapi::api_error_schema());

        for info in inventory::iter::<SchemaInfo> {
            schemas.insert(info.name.to_string(), (info.schema_fn)());
            for (nested_name, nested_schema) in (info.nested_fn)() {
                schemas.entry(nested_name).or_insert(nested_schema);
            }
        }

        let mut paths = HashMap::new();
        for route in inventory::iter::<RouteInfo> {
            let description = if route.description.is_empty() {
                None
            } else {
                Some(route.description.to_string())
            };

            let tags: Vec<String> = route.tags.iter().map(|s| s.to_string()).collect();

            let status_code = route.success_status.to_string();

            // Build security requirements for this operation
            let security: Vec<HashMap<String, Vec<String>>> = route.security.iter().map(|s| {
                let scheme_name = match *s {
                    "bearer" => "bearerAuth",
                    other => other,
                };
                let mut map = HashMap::new();
                map.insert(scheme_name.to_string(), vec![]);
                map
            }).collect();

            // Build response schema ref
            let schema_ref_value = if route.success_status == 204 {
                None
            } else if route.is_vec_response {
                // Array response: inline array schema with $ref items
                Some(serde_json::json!({
                    "type": "array",
                    "items": { "$ref": format!("#/components/schemas/{}", route.vec_inner_type_name) }
                }))
            } else {
                Some(serde_json::json!({ "$ref": format!("#/components/schemas/{}", route.response_type_name) }))
            };

            let success_desc = openapi::status_description(route.success_status).to_string();

            let operation = openapi::Operation {
                summary: Some(route.handler_name.replace('_', " ")),
                description,
                operation_id: Some(route.handler_name.to_string()),
                tags,
                parameters: route.parameters.to_vec(),
                request_body: if route.has_body {
                    Some(openapi::RequestBody {
                        required: true,
                        content_type: "application/json".to_string(),
                        schema_ref: format!("#/components/schemas/{}", route.body_type_name),
                    })
                } else {
                    None
                },
                responses: {
                    let mut map = HashMap::new();

                    map.insert(status_code, openapi::ResponseDef {
                        description: success_desc,
                        schema_ref: schema_ref_value,
                    });

                    // Error responses
                    map.insert("400".to_string(), openapi::ResponseDef {
                        description: "Bad Request".to_string(),
                        schema_ref: Some(serde_json::json!({ "$ref": "#/components/schemas/ApiError" })),
                    });
                    if route.has_body {
                        map.insert("422".to_string(), openapi::ResponseDef {
                            description: "Validation Failed".to_string(),
                            schema_ref: Some(serde_json::json!({ "$ref": "#/components/schemas/ApiError" })),
                        });
                    }
                    map.insert("500".to_string(), openapi::ResponseDef {
                        description: "Internal Server Error".to_string(),
                        schema_ref: Some(serde_json::json!({ "$ref": "#/components/schemas/ApiError" })),
                    });

                    map
                },
                security,
            };

            let path_item = paths.entry(route.path.to_string()).or_insert_with(HashMap::new);
            path_item.insert(route.method.to_lowercase(), operation);
        }

        openapi::OpenApiSpec {
            openapi: "3.1.0".to_string(),
            info: openapi::Info {
                title: self.title.clone(),
                version: self.version.clone(),
            },
            servers: self.servers.clone(),
            paths,
            schemas,
            security_schemes: self.security_schemes.clone(),
        }
    }
}

impl openapi::OpenApiSpec {
    /// Enhanced to_json that includes dynamic query parameters
    pub fn to_json_with_query_params(&self) -> serde_json::Value {
        let mut val = self.to_json();

        // Inject query params from RouteInfo
        for route in inventory::iter::<RouteInfo> {
            if let Some(qfn) = route.query_params_fn {
                let dyn_params = qfn();
                if !dyn_params.is_empty() {
                    let method = route.method.to_lowercase();
                    let path = route.path;
                    let escaped = path.replace('~', "~0").replace('/', "~1");
                    let pointer = format!("/paths/{}/{}", escaped, method);
                    if let Some(op) = val.pointer_mut(&pointer) {
                        let params = op.get("parameters")
                            .and_then(|v| v.as_array())
                            .cloned()
                            .unwrap_or_default();
                        let mut all_params = params;
                        for dp in &dyn_params {
                            let mut param = serde_json::json!({
                                "name": dp.name,
                                "in": dp.location,
                                "required": dp.required,
                                "schema": { "type": dp.schema_type }
                            });
                            if let Some(desc) = &dp.description {
                                param["description"] = serde_json::Value::String(desc.clone());
                            }
                            all_params.push(param);
                        }
                        op["parameters"] = serde_json::Value::Array(all_params);
                    }
                }
            }
        }

        val
    }
}
