pub mod openapi;

use axum::Router;
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use serde::Serialize;
use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::sync::Arc;

// Re-exports
pub use hayai_macros::{get, post, put, delete, ApiModel};
pub use serde;
pub use serde_json;
pub use schemars;
pub use inventory;
pub use axum;

pub mod prelude {
    pub use crate::{get, post, put, delete, ApiModel};
    pub use crate::{HayaiApp, Dep, ApiError, Validate};
    pub use serde::{Serialize, Deserialize};
    pub use schemars::JsonSchema;
}

/// Validation trait generated by ApiModel derive
pub trait Validate {
    fn validate(&self) -> Result<(), Vec<String>>;
}

/// Blanket impl for types without validation
impl Validate for () {
    fn validate(&self) -> Result<(), Vec<String>> {
        Ok(())
    }
}

/// Trait for schema patches from validation attributes
pub trait HasSchemaPatches {
    fn patch_schema(props: &mut HashMap<String, openapi::PropertyPatch>);
}

/// Application state holding dependency injection container
#[derive(Clone)]
pub struct AppState {
    deps: Arc<HashMap<TypeId, Arc<dyn Any + Send + Sync>>>,
}

impl AppState {
    pub fn new() -> Self {
        Self {
            deps: Arc::new(HashMap::new()),
        }
    }
    
    pub fn get<T: 'static + Send + Sync>(&self) -> Option<Arc<T>> {
        self.deps
            .get(&TypeId::of::<T>())
            .and_then(|v| v.clone().downcast::<T>().ok())
    }
}

/// Dependency injection extractor
pub struct Dep<T: 'static + Send + Sync>(Arc<T>);

impl<T: 'static + Send + Sync> Dep<T> {
    pub fn from_app_state(state: &AppState) -> Self {
        let arc = state.get::<T>().expect("Dependency not registered");
        Dep(arc)
    }
}

impl<T: 'static + Send + Sync> std::ops::Deref for Dep<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

/// API Error type
#[derive(Debug, Serialize)]
pub struct ApiError {
    #[serde(skip)]
    pub status: StatusCode,
    pub error: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub details: Vec<String>,
}

impl ApiError {
    pub fn bad_request(msg: String) -> Self {
        Self { status: StatusCode::BAD_REQUEST, error: msg, details: vec![] }
    }
    
    pub fn not_found(msg: String) -> Self {
        Self { status: StatusCode::NOT_FOUND, error: msg, details: vec![] }
    }
    
    pub fn internal(msg: String) -> Self {
        Self { status: StatusCode::INTERNAL_SERVER_ERROR, error: msg, details: vec![] }
    }
    
    pub fn validation_error(errors: Vec<String>) -> Self {
        Self {
            status: StatusCode::UNPROCESSABLE_ENTITY,
            error: "Validation failed".into(),
            details: errors,
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let body = serde_json::to_string(&self).unwrap();
        (self.status, [("content-type", "application/json")], body).into_response()
    }
}

/// Route information collected by proc macros
pub struct RouteInfo {
    pub path: &'static str,
    pub axum_path: &'static str,
    pub method: &'static str,
    pub handler_name: &'static str,
    pub response_type_name: &'static str,
    pub parameters: &'static [openapi::Parameter],
    pub has_body: bool,
    pub body_type_name: &'static str,
    pub register_fn: fn(Router<AppState>) -> Router<AppState>,
}

inventory::collect!(RouteInfo);

/// Schema information collected by ApiModel derive
pub struct SchemaInfo {
    pub name: &'static str,
    pub schema_fn: fn() -> openapi::Schema,
}

inventory::collect!(SchemaInfo);

/// The main application struct
pub struct HayaiApp {
    deps: HashMap<TypeId, Arc<dyn Any + Send + Sync>>,
    routes: Vec<&'static RouteInfo>,
}

impl HayaiApp {
    pub fn new() -> Self {
        Self {
            deps: HashMap::new(),
            routes: Vec::new(),
        }
    }
    
    pub fn dep<T: 'static + Send + Sync>(mut self, dep: T) -> Self {
        self.deps.insert(TypeId::of::<T>(), Arc::new(dep));
        self
    }
    
    pub fn route(mut self, route_fn: fn() -> &'static RouteInfo) -> Self {
        self.routes.push(route_fn());
        self
    }
    
    pub async fn serve(self, addr: &str) {
        // Generate OpenAPI spec before consuming deps
        let spec = self.generate_openapi_spec();
        
        let state = AppState {
            deps: Arc::new(self.deps),
        };
        let spec_json = serde_json::to_string_pretty(&spec.to_json()).unwrap();
        
        // Build router
        let mut app = Router::new();
        
        for route in &self.routes {
            app = (route.register_fn)(app);
        }
        
        // Add OpenAPI spec endpoint
        let spec_json_clone = spec_json.clone();
        app = app.route("/openapi.json", axum::routing::get(move || {
            let spec = spec_json_clone.clone();
            async move {
                (StatusCode::OK, [("content-type", "application/json")], spec)
            }
        }));
        
        // Add Swagger UI
        app = app.route("/docs", axum::routing::get(|| async {
            (StatusCode::OK, [("content-type", "text/html")], SWAGGER_HTML)
        }));
        
        let app = app.with_state(state);
        
        let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
        println!("ðŸš€ Hayai server running at http://{}", addr);
        println!("ðŸ“– Swagger UI available at http://{}/docs", addr);
        axum::serve(listener, app).await.unwrap();
    }
    
    fn generate_openapi_spec(&self) -> openapi::OpenApiSpec {
        // Collect all schemas
        let mut schemas = HashMap::new();
        for info in inventory::iter::<SchemaInfo> {
            schemas.insert(info.name.to_string(), (info.schema_fn)());
        }
        
        // Build paths
        let mut paths = HashMap::new();
        for route in &self.routes {
            let operation = openapi::Operation {
                summary: Some(route.handler_name.replace('_', " ")),
                operation_id: Some(route.handler_name.to_string()),
                parameters: route.parameters.to_vec(),
                request_body: if route.has_body {
                    Some(openapi::RequestBody {
                        required: true,
                        content_type: "application/json".to_string(),
                        schema_ref: format!("#/components/schemas/{}", route.body_type_name),
                    })
                } else {
                    None
                },
                responses: {
                    let mut map = HashMap::new();
                    map.insert("200".to_string(), openapi::ResponseDef {
                        description: "Successful response".to_string(),
                        schema_ref: Some(format!("#/components/schemas/{}", route.response_type_name)),
                    });
                    map
                },
            };
            
            let path_item = paths.entry(route.path.to_string()).or_insert_with(HashMap::new);
            path_item.insert(route.method.to_lowercase(), operation);
        }
        
        openapi::OpenApiSpec {
            openapi: "3.1.0".to_string(),
            info: openapi::Info {
                title: "Hayai API".to_string(),
                version: "0.1.0".to_string(),
            },
            paths,
            schemas,
        }
    }
}

const SWAGGER_HTML: &str = r#"<!DOCTYPE html>
<html>
<head>
    <title>Hayai API - Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css" >
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"> </script>
    <script>
    SwaggerUIBundle({
        url: "/openapi.json",
        dom_id: '#swagger-ui',
        presets: [SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset],
        layout: "BaseLayout"
    })
    </script>
</body>
</html>"#;
